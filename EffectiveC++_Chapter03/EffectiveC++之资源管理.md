所谓资源就是，一旦用了它，将来必须还给系统，如果不这样，糟糕的事情就会发生， C++程序中最常用的资源就是动态分配内存，但内存只是你必须管理的众多资源之一，其他的资源还包括文件描述器、互斥锁、图形界面中的字形和笔刷、数据库连接、以及网络sockets等。不论哪一种资源，重要的是，当你不再使用它时， 必须将它还给系统。


## 以对象管理资源

把资源放进对象内，我们便可倚赖C++的析构函数自动调用机制确保资源被释放

许多资源被动态分配于heap内而后被用于单一区块或函数内，它们应该在控制流离开那个区块或函数时被释放。标准程序库提供的auto_ptr正是针对这种形势而设计的订制产品， auto_ptr是个类指针对象，也就是所谓的`智能打针`，基析构函数自动对其所指对象调用delete

下例示范如何使用auto_ptr以避免f函数潜在的资源泄漏可能性：

```
void f() {
	std::auto_ptr<Investment> pInv(createInvestment());
}
```

这个简单的例子示范了

> 以对象管理资源的两个关键想法：

* **获得资源后立刻放进管理对象内:** 以上代码中createInvestment 返回的资源被梁在其管理者auto_ptr的初值，实际上`以对象管理资源`的观念常被称为`资源聚地时机食不果腹初始化时机(Resource Acquisition Is Initialization; RAII)`,因为我们几乎问题在获得一笔资源后于同一语句内以它初始化某个管理对象，有时候获得的资源被拿来赋值某个管理对象，但不论哪一种做法，每一笔资源都在获得的同时立刻被放进管理对象中
* **管理对象运用析构函数确保资源被释放: ** 不论控制流如何离开区块，一旦对象被销毁其析构函数自然会被自动调用，于是资源被释放，如果资源释放动作可能导致招聘异常，事情变得有点棘手；

上例中使用auto_ptr 被销毁时会自动删除它所指之物，所以一定要注意别让多个auto_ptr同时指向同一对象。如果真是那样，对象会被删除一次以上，而那会使你的程序出现未定义的错误，为了预防这个问题，auto_ptrs有一个不寻常的性质： 若通过copy构造函数或copay assignment操作符复制它们，它们会变成null，而复制所得的指针将取得资源的唯一拥有权；

这就意味着auto_ptrs并非管理动态分配资源的最佳方法

所以提出了auto_ptrs的替代方案是`引用计数弄智慧指针(reference-counting smart pointer; RCSP)`，所谓的RCSP也是个智能指针，持续追踪共有多少对象指向某笔资源，并在无从指向它时，自动删除该资源，RCSPs提供的行为类似垃圾回收(garbage collection), 不同的是RCSPs无法打破环状引用(cycles of references)


## 在资源管理类中小心**_coping_**行为

> 当一个RAII对象被复制时，会发生什么事？

大多数情况下，可以造反以下两种方法：

* **禁止复制**: 许多时候允许RAII对象被复制并不合理，可以将copying操作声明为private
* 对底层资源祭出`引用计数法(reference-count)` 有时候我们希望保有资源，直到它的最后一个使用者被销毁，这种情况下复制RAII对象时，应该将资源的`被引用数` 递增。
* **复制底部资源**
* **转移底部资源的拥有权**

## 在资源管理类中提供对原始资源的访问

